#+TITLE: Roots
#+DATE: 2024
#+PROPERTY: header-args :tangle init.el
#+STARTUP: overview

* Rationale
This is Roots. The name doesn't really mean anything. As you may have guessed,
this file contains configuration for GNU Emacs.

I've refrained from adding long comments to the code describing my configuration
choices; these comments add visual noise that I don't want to scan over, and
experience has shown that they're almost never as good as the actual docstrings.

You, the potential reader of this file, would almost certainly be better served
reading the help buffer of variables or functions than whatever nonsense I could
come up with as commentary.

This file must be tangled or otherwise loaded with the help of ~org-babel~ in
order to activate any of the configuration contained within it. This can be
easily done from the root of this repository with ~make retangle~.

Care has been taken to leverage ~use-package~ for lazy loading. The argument for
lazy loading is mostly taken from the [[info:use-package#Deferring loading][Deferring loading]] section of the
~use-package~ manual. Packages are loaded lazily by default according to
~use-package-always-defer~; see the ~use-package~ setup in ~early-init.el~.

* Preliminary
This section takes care of some preliminary concerns.

** Lexical Binding
For a discussion on what lexical binding is, and why this is
necessary, see the [[info:elisp#Variable Scoping][Variable Scoping]] node in the manual.

#+BEGIN_SRC emacs-lisp
  ;;; -*- lexical-binding: t; no-byte-compile: t -*-
  ;; This file is generated with `org-babel'. See the accompanying file
  ;; `roots.org' for the rationale behind the code.
#+END_SRC
** Compile Angel

#+BEGIN_SRC emacs-lisp
  (use-package compile-angel :demand t
    :custom (compile-angel-verbose t)
    :config
    (mapc (lambda (file)
            (push file compile-angel-excluded-files-regexps))
          '("modus-vivendi-theme.el"
            "modus-operandi-theme.el"
            "early-init.el"
            "init.el"
            "local-config.el"
            "var/"))

    (compile-angel-on-load-mode))

#+END_SRC
** Profiling
This section enables ~esup~, the Emacs Start Up Profiler.

#+BEGIN_SRC emacs-lisp
  (use-package esup
    :config (setq esup-depth 0))
#+END_SRC
* Core Platform
This section defines what I consider "sane defaults;" there are so many
variations of that idea out there that I doubt my opinions here are needed; just
try it and see if you like it.

** Defaults
These settings are essentially subjective, but serve to disable some annoyances
(lockfiles, audible bell) or improve ergonomics (~TAB~ for completion instead of
~C-M-i~, ~winner-mode~).

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :hook ((after-init . column-number-mode)
           (after-init . electric-pair-mode)
           (after-init . global-auto-revert-mode)
           (after-init . global-so-long-mode)
           (after-init . global-subword-mode)
           (after-init . global-visual-line-mode)
           (after-init . global-visual-wrap-prefix-mode)
           (after-init . minibuffer-depth-indicate-mode)
           (after-init . kill-ring-deindent-mode)
           (after-init . repeat-mode)
           (after-init . save-place-mode)
           (after-init . savehist-mode)
           (after-init . winner-mode)

           (before-save . delete-trailing-whitespace)
           (prog-mode . display-line-numbers-mode)
           (prog-mode . smerge-mode)
           (display-line-numbers-mode . hl-line-mode))

    :bind (("C-c D" . duplicate-dwim)
           ("C-c SPC" . just-one-space)
           ("C-c tv" . view-mode)
           ("C-c tw" . visual-line-mode)
           ("C-c wr" . winner-redo)
           ("C-c wu" . winner-undo)
           ("C-h '" . describe-char)
           ("C-x C-f" . ffap)
           ("C-x C-l" . nil)
           ("C-x m" . nil)
           ("C-z" . bury-buffer)
           ;; Touchpad
           ("<pinch>" . nil)
           ([wheel-left] . (lambda () (interactive) (scroll-left 1)))
           ([wheel-right] . (lambda () (interactive) (scroll-right 1))))

    :custom
    ;; Startup
    (inhibit-startup-echo-area-message t)
    (inhibit-startup-screen t)
    (inhibit-x-resources t)
    (initial-major-mode 'fundamental-mode)
    (initial-scratch-message nil)

    ;; Tabs and spaces
    (indent-tabs-mode nil)
    (sentence-end-double-space nil)
    (tab-always-indent 'complete)
    (tab-width 4)

    ;; Line numbers
    (display-line-numbers-grow-only t)
    (display-line-numbers-widen t)
    (display-line-numbers-width 3)

    ;; Mode line
    (mode-line-format
     (delete '(vc-mode vc-mode)
             mode-line-format))

    ;; Files
    (create-lockfiles nil)
    (large-file-warning-threshold (* 100 1024 1024))
    (make-backup-files nil)
    (require-final-newline t)

    ;; Interaction
    (enable-local-variables :safe)
    (enable-recursive-minibuffers t)
    (isearch-lazy-count t)
    (lazy-count-prefix-format "(%s/%s) ")
    (tooltip-mode nil)
    (use-dialog-box nil)
    (use-file-dialog nil)
    (use-short-answers t)
    (vc-follow-symlinks t)

    ;; show-paren
    (show-paren-when-point-in-periphery t)
    (show-paren-when-point-inside-paren t)

    ;; Scrolling
    (fast-but-imprecise-scrolling t)
    (pixel-scroll-precision-mode t)
    (scroll-conservatively 101)

    ;; Miscellaneous
    (Man-notify-method 'pushy)
    (custom-safe-themes t)
    (custom-unlispify-tag-names nil)
    (disabled-command-function nil)
    (fill-column 80)
    (global-auto-revert-non-file-buffers t)
    (kill-do-not-save-duplicates t)
    (load-prefer-newer noninteractive)
    (native-comp-async-report-warnings-errors nil)
    (ring-bell-function 'ignore)
    (uniquify-buffer-name-style 'forward)
    (warning-minimum-level :error)

    :config
    (dolist (buffer
             '("magit:"
               "\\*help"
               "\\*shell"
               "\\*Proced"
               "\\*Copilot"))
      (add-to-list 'display-buffer-alist
                   `(,buffer display-buffer-same-window))))
#+END_SRC
** Recent Files

#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :hook (after-init . recentf-mode)
    :custom (recentf-max-saved-items 200)
    :config (dolist (exclusion
                     '("\\/sudo:root@localhost.*"
                       "\\.org_archive$"
                       "\\.epub$"
                       "\\.gif$"
                       "\\.jpe?g$"
                       "\\.m4v$"
                       "\\.mp4$"
                       "\\.pdf$"
                       "\\.png$"
                       "\\.webp$"))
              (add-to-list 'recentf-exclude exclusion)))
#+END_SRC
** Directories
Emacs normally fails to perform a file operation when trying to write or copy
files into directories which do not yet exist. This behavior is almost never
helpful; instead, if I'm working in the minibuffer and explicitly say to put a
file into a directory which does not yet exist, I mean that the directory should
be created and the file should be put there.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :hook (after-init . r/advise-file-operations)
    :config
    (defun r/make-directory-if-not-exists (&rest r)
      "Create parent directory if not exists while operating on `FILENAME' in `R'."
      (dolist (filename r)
        (when (stringp filename)
          (make-directory (file-name-directory filename) t))))

    (defun r/advise-file-operations ()
      (dolist (f '(find-file copy-file rename-file))
        (advice-add f :before
                    (lambda (&rest r)
                      (apply #'r/make-directory-if-not-exists r))))))
#+END_SRC
** Helpful

#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :bind (("C-h f" . helpful-callable)
           ("C-h v" . helpful-variable)
           ("C-h k" . helpful-key)))
#+END_SRC
** No Littering

#+BEGIN_SRC emacs-lisp
  (use-package no-littering :demand)
#+END_SRC
** Minions

#+BEGIN_SRC emacs-lisp
  (use-package minions
    :hook (after-init . minions-mode)
    :custom (minions-mode-line-lighter "--"))
#+END_SRC
** Ibuffer

#+BEGIN_SRC emacs-lisp
  (use-package ibuffer-project
    :hook (ibuffer . r/ibuffer-project)
    :bind ("C-x C-b" . ibuffer)
    :config
    (defun r/ibuffer-project ()
      (setq ibuffer-filter-groups (ibuffer-project-generate-filter-groups))
      (unless (eq ibuffer-sorting-mode 'project-file-relative)
        (ibuffer-do-sort-by-project-file-relative))))
#+END_SRC
** PATH

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :hook (after-init . exec-path-from-shell-initialize))
#+END_SRC
** Dired
Dired is the greatest file manager ever created. The existence of ~wdired~ alone
makes it superior to any graphical file manager I've ever seen; add on
everything else dired is capable of, and there's just no contest.

#+BEGIN_SRC emacs-lisp
  (use-package dired :ensure nil
    :hook ((dired-mode . dired-hide-details-mode)
           (dired-mode . auto-revert-mode))
    :bind (:map dired-mode-map
                ("C-c C-e" . wdired-change-to-wdired-mode)
                ;; no ffap in dired
                ("C-x C-f" . find-file))
    :custom
    (dired-listing-switches "-alhv --group-directories-first")
    (dired-dwim-target t)
    (dired-clean-up-buffers-too nil)
    :config (require 'dired-x))

  (use-package diredfl
    :hook (after-init . diredfl-global-mode))

  (use-package dired-subtree :after dired
    :bind (:map dired-mode-map
                ("TAB" . dired-subtree-cycle))
    :custom (dired-subtree-use-backgrounds nil))
#+END_SRC
** Proced

#+BEGIN_SRC emacs-lisp
  (use-package proced
    :hook (proced-mode . (lambda () (visual-line-mode -1) (toggle-truncate-lines 1)))
    :custom
    (proced-auto-update-flag t)
    (proced-enable-color-flag t)
    (proced-format 'custom)
    :config
    (add-to-list
     'proced-format-alist
     '(custom user pid ppid sess tree pcpu pmem rss start time state (args comm))))
#+END_SRC
** Dubious hacks
This is where I put any purported "performance" code and "fixes", for which I
have neither evidence supporting the supposed benefit, nor reason to doubt it.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :custom
    (gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
    (auto-mode-case-fold nil)
    (pgtk-wait-for-event-timeout 0.001)

    (bidi-display-reordering 'left-to-right)
    (bidi-inhibit-bpa t)
    (bidi-paragraph-direction 'left-to-right))
#+END_SRC
** Custom Code
This section is for generally useful functions and keybindings without a
specific package.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :bind (("C-M-j" . r/top-join-line)
           ("C-M-d" . r/kill-whole-word)
           ("C-c cu" . r/sudo-find-file)
           ("C-c mw" . r/mark-symbol-at-point)
           ("C-c n" . r/system-filebrowser)
           ("C-g" . r/keyboard-quit))
    :config
    (defun r/sudo (command)
      (let ((default-directory
             (concat "/sudo::"
                     (expand-file-name default-directory))))
        (call-interactively command)))

    (defun r/project-root ()
      "Return the current project root."
      (require 'project)
      (expand-file-name (project-root (project-current t))))

    (defun r/project-relative-path ()
      "Return the path to the current file relative to the project root."
      (file-relative-name buffer-file-name (r/project-root)))

    (defun r/sudo-async-shell-command (&optional command)
      (interactive)
      (if command
          (r/sudo (lambda ()
                    (interactive)
                    (async-shell-command command)))
        (r/sudo #'async-shell-command)))

    (defun r/sudo-find-file ()
      (interactive)
      (r/sudo #'find-file))

    (defun r/top-join-line ()
      (interactive)
      (delete-indentation 1))

    (defun r/mark-symbol-at-point ()
      (interactive)
      (thing-at-point--beginning-of-symbol)
      (set-mark (point))
      (forward-symbol 1))

    (defun r/kill-relative-path ()
      "Kill the path to the current file relative to the project root."
      (interactive)
      (kill-new (r/project-relative-path)))

    (defun r/keyboard-quit ()
      (interactive)
      (if (> (minibuffer-depth) 0)
          (abort-recursive-edit)
        (keyboard-quit)))

    (defun r/system-open-command ()
      (if (eq system-type 'darwin)
          "open"
        "setsid -w xdg-open"))

    (defun r/system-filebrowser ()
      (interactive)
      (async-shell-command
       (format "%s %s"
               (r/system-open-command)
               default-directory)))

    (defun r/enable-mode-maybe (mode state)
      "Enable a mode if we're looking at a real buffer, but not in a
  minibuffer. Useful to prevent loading extra code in `consult-buffer'."
      (when (not (minibufferp))
        (run-with-idle-timer
         0.1 nil (lambda (buf)
                   (when (and (buffer-live-p buf)
                              (emacs-init-time)
                              (with-current-buffer buf
                                (get-buffer-window buf 'visible)))
                     (with-current-buffer buf
                       (funcall mode state))))
         (current-buffer))))

    (defun r/kill-whole-word ()
      (interactive)
      (kill-word 1)
      (backward-kill-word 1)))
#+END_SRC
* Core Extensions
This section sets up a general layer of useful features; the focus
is on power and ergonomics.

** Editing and Navigation

#+BEGIN_SRC emacs-lisp
  (use-package devil :pin melpa
    :hook (after-init . global-devil-mode)
    :custom (devil-all-keys-repeatable t))

  (use-package avy
    :bind ("C-'" . avy-goto-char-timer)
    :custom (avy-all-windows t))

  (use-package iedit
    :bind (("C-." . iedit-mode)
           (:map iedit-mode-occurrence-keymap
                 ("<tab>" . nil)
                 ("TAB" . nil))
           (:map iedit-mode-keymap
                 ("<tab>" . nil)
                 ("TAB" . nil))))

  (use-package wrap-region
    :hook (after-init . wrap-region-mode)
    :config (wrap-region-add-wrapper "`" "`"))

  (use-package wgrep
    :custom (wgrep-auto-save-buffer t))

  ;; wip
  (use-package better-jumper
    :hook ((after-init . better-jumper-mode)
           (pre-command . r/maybe-save-jump))
    :bind (("C-c jn" . better-jumper-jump-forward)
           ("C-c jp" . better-jumper-jump-backward))
    :config
    (defvar r/jump-commands
      '(previous-line
        next-line
        forward-word
        backward-word
        beginning-of-buffer
        end-of-buffer
        beginning-of-line
        end-of-line
        yank-pop
        yank
        org-yank
        lispy-yank
        lispy-move-beginning-of-line
        lispy-move-end-of-line
        avy-goto-char-timer))
    (defun r/maybe-save-jump ()
      (when (memq real-this-command r/jump-commands)
        (better-jumper-set-jump))))
#+END_SRC
** Interaction and Completion
These packages work together as building blocks to extend default Emacs input
scenarios in impressive ways.

*** Marginalia

#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :hook (after-init . marginalia-mode))
#+END_SRC
*** Orderless

#+BEGIN_SRC emacs-lisp
(use-package orderless
  :custom (completion-styles '(orderless basic)))
#+END_SRC
*** Vertico

#+BEGIN_SRC emacs-lisp
  (use-package vertico
    :hook ((after-init . vertico-mode)
           (rfn-eshadow-update-overlay . vertico-directory-tidy))
    :bind (:map vertico-map
                ("RET" . vertico-directory-enter)
                ("DEL" . vertico-directory-delete-char))
    :custom
    (vertico-cycle t)
    (vertico-count 12)
    (vertico-resize nil))
#+END_SRC
*** Consult

#+BEGIN_SRC emacs-lisp
  (use-package consult
    :bind (("M-g i" . consult-imenu)
           ("C-x b" . consult-buffer)
           ("C-x pr" . consult-ripgrep)
           ("C-c cl" . consult-line)
           ("C-c cr" . r/consult-rg-current-directory)
           ("C-c cf" . r/consult-fd-current-directory)
           (:map minibuffer-local-map
                 ("C-\\" . consult-history)))
    :custom
    (xref-show-xrefs-function 'consult-xref)
    (xref-show-definitions-function 'consult-xref)
    :config
    (defun r/consult-rg-current-directory ()
      (interactive)
      (consult-ripgrep default-directory))
    (defun r/consult-fd-current-directory ()
      (interactive)
      (consult-fd default-directory)))

  (use-package consult-dir
    :bind (:map minibuffer-mode-map
                ("C-M-d" . consult-dir)))
#+END_SRC
*** Embark

#+BEGIN_SRC emacs-lisp
  (use-package embark
    :bind (("C-;" . embark-act)
           (:map minibuffer-local-map
                 ("C-'" . embark-act-all)
                 ("C-c C-e" . embark-export)))
    :custom
    (embark-indicators '(embark-minimal-indicator))
    (embark-prompter 'embark-completing-read-prompter))

  (use-package embark-consult)
#+END_SRC
*** Corfu

#+BEGIN_SRC emacs-lisp
  (use-package corfu
    :hook ((after-init . global-corfu-mode)
           (after-init . corfu-popupinfo-mode)
           (minibuffer-setup . corfu-enable-in-minibuffer))
    :custom
    (corfu-auto t)
    (corfu-auto-delay 0.5)
    (corfu-cycle t)
    (corfu-popupinfo-delay '(0.5 . 0.1))
    :config
    (defun corfu-enable-in-minibuffer ()
      "Enable Corfu in the minibuffer if `completion-at-point' is bound."
      (when (where-is-internal #'completion-at-point (list (current-local-map)))
        (setq-local corfu-echo-delay nil)
        (corfu-mode 1))))
#+END_SRC
** Tidying Buffers

#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :hook (prog-mode . ws-butler-mode))

  (use-package apheleia
    :hook (prog-mode . apheleia-mode))

  (use-package editorconfig
    :hook (after-init . editorconfig-mode))
#+END_SRC
** External Files

#+BEGIN_SRC emacs-lisp
  (use-package openwith
    :hook (emacs-startup . openwith-mode)
    :custom (openwith-associations
             `(("\\.\\(?:mpe?g\\|avi\\|wmv\\|m4v\\|mp4\\|gif\\|mp3\\)\\'"
                ,(r/system-open-command) (file))
               ("\\.\\(?:jp?g\\|png\\|pdf\\|epub\\|webp\\|tga\\)\\'"
                ,(r/system-open-command) (file)))))
#+END_SRC
* Org Mode
The swiss-army outline tool.

** Base Layer
This section sets up a baseline for Org Mode as an outlining tool.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :hook (org-mode . auto-fill-mode)
    :bind (("C-c sl" . org-store-link)
           (:map org-mode-map
                 ("C-'" . nil)
                 ("C-c &" . nil)
                 ("M-g i" . consult-org-heading))
           (:map org-src-mode-map
                 ("C-c C-c" . org-edit-src-exit)))
    :custom
    (org-M-RET-may-split-line nil)
    (org-adapt-indentation t)
    (org-enforce-todo-dependencies t)
    (org-fold-catch-invisible-edits 'show-and-error)
    (org-hide-emphasis-markers t)
    (org-hide-leading-stars t)
    (org-src-window-setup 'current-window)
    (org-startup-indented t)
    (org-use-tag-inheritance nil)
    (org-list-demote-modify-bullet
     '(("+" . "-") ("-" . "+"))))
#+END_SRC
** Calendar
All I really want in a calendar is to see the days of the month and the week
numbers. This thing does that beautifully, and it's right here.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :hook (calendar-today-visible . calendar-mark-today)
    :custom
    (calendar-week-start-day 1)
    ;; Show week numbers
    (calendar-intermonth-text
     '(propertize
       (format "%2d"
               (car
                (calendar-iso-from-absolute
                 (calendar-absolute-from-gregorian (list month day year)))))
       'font-lock-face 'font-lock-keyword-face))
    :config
    (add-to-list 'display-buffer-alist
                 '("\\*Calendar*"
                   display-buffer-at-bottom)))
#+END_SRC
** Workflow Setup
This section defines my capture and agenda workflow.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :hook (org-agenda-mode . hl-line-mode)
    :bind (("C-c oa" . org-agenda)
           ("C-c oc" . org-capture))
    :config
    ;; The `display-buffer-no-window' function behaves differently than other
    ;; `display-buffer' actions, requiring a non-nil `allow-no-window' as an
    ;; argument. This quasi-quoted construct is distilled from the construct in
    ;; the stack exchange answer: https://emacs.stackexchange.com/a/72045
    (add-to-list 'display-buffer-alist
                 `(,org-babel-error-buffer-name
                   display-buffer-no-window
                   (allow-no-window . t)))
    (add-to-list 'org-export-backends 'md)
    :custom
    (org-agenda-files (list org-directory))
    (org-agenda-span 10)
    (org-agenda-start-day "-3d")
    (org-agenda-start-on-weekday nil)
    (org-agenda-window-setup 'current-window)

    (org-clock-clocked-in-display 'frame-title)
    (org-log-done 'time)
    (org-log-into-drawer t)
    (org-log-refile 'time)
    (org-refile-targets
     '((nil :maxlevel . 3)
       (org-agenda-files :maxlevel . 2)))

    (org-directory "~/mega/org/")
    (org-default-notes-file (concat org-directory "backlog.org"))
    (org-archive-location (concat org-directory "archive/%s_archive::"))
    (org-capture-templates
     '(("t" "Todo" entry (file "backlog.org")
        "* TODO [#B] %?\nSCHEDULED: %t\n** Estimate:\n** Actions [/]\n** Notes")
       ("r" "Region to todo" entry (file "backlog.org")
        "* TODO [#B] %i\nSCHEDULED: %t\n** Estimate:\n** Actions [/]\n** Notes"
        :immediate-finish t)
       ("y" "Yakshaving" entry (file "backlog.org")
        "* TODO [#C] %? :yakshaving:\n** Estimate:\n** Actions [/]\n** Notes")
       ("j" "Journal" plain (file+olp+datetree "journal.org")
        "%?\n---")
       ("i" "Idea" plain (file+headline "backlog.org" "Ideas")
        "+ %U\n  %?"))))
#+END_SRC
** Tweaks
This section contains custom code and packages for tweaking Org outside
of what its customization trivially offers.

#+BEGIN_SRC emacs-lisp
  (use-package org-autolist
    :hook (org-mode . org-autolist-mode))

  (use-package org
    :bind ((:map org-mode-map
                 ([return] . r/org-dwim-at-point))
           (:map org-read-date-minibuffer-local-map
                 ("C-f" . r/org-calendar-forward-day)
                 ("C-b" . r/org-calendar-backward-day)
                 ("C-n" . r/org-calendar-forward-week)
                 ("C-p" . r/org-calendar-backward-week)))
    :config
    (defun r/org-calendar-forward-day ()
      (interactive)
      (org-eval-in-calendar '(calendar-forward-day 1)))
    (defun r/org-calendar-backward-day ()
      (interactive)
      (org-eval-in-calendar '(calendar-backward-day 1)))
    (defun r/org-calendar-forward-week ()
      (interactive)
      (org-eval-in-calendar '(calendar-forward-week 1)))
    (defun r/org-calendar-backward-week ()
      (interactive)
      (org-eval-in-calendar '(calendar-backward-week 1)))

    ;; don't use `other-window' when opening file links
    (assq-delete-all 'file org-link-frame-setup)
    (add-to-list 'org-link-frame-setup '(file . find-file))

    (defun r/org-dwim-at-point ()
      "Toggle the todo state of a headline, toggle a checkbox, or follow
    a link."
      (interactive)
      (let* ((context (org-element-context))
             (checkbox (org-element-property :checkbox context))
             (todo (org-element-property :todo-type context))
             (link (equal (org-element-type context) 'link)))
        (cond
         (link (org-open-at-point))
         (todo (org-todo))
         (checkbox
          (let ((operation
                 (cond ((equal checkbox 'off) '(16))
                       ((equal checkbox 'on) nil)
                       (t t))))
            (org-toggle-checkbox operation)))
         (t (org-return)))
        (when (or todo checkbox)
          (org-update-checkbox-count)
          (org-update-parent-todo-statistics)))))
#+END_SRC
** Eye Candy
This section enables spicing up the buffer with some unicode characters and sets
any face settings that I don't want themes to override.

#+BEGIN_SRC emacs-lisp
  (use-package org-superstar
    :hook (org-mode . org-superstar-mode)
    :custom
    ;; fixes bug with customized `org-ellipsis'
    ;; https://emacs.stackexchange.com/a/50166
    (org-cycle-separator-lines -1)
    (org-ellipsis " ⯆")
    (org-superstar-headline-bullets-list '("●")))
#+END_SRC
* Technologies
This section provides configuration for specific technologies such as
programming languages and corresponding language servers.

** Git
Although Emacs does come with a built-in interface to version control, it's
cumbersome and inelegant compared to Magit. This section sets up Magit and a few
other utility packages related to git.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :custom
    (magit-diff-refine-hunk 'all)
    (magit-display-buffer-function 'display-buffer))

  (use-package why-this
    :custom (why-this-annotate-enable-heat-map nil)
    :custom-face
    (why-this-face
     ((t ( :foreground unspecified :inherit font-lock-comment-face)))))

  (use-package diff-hl
    :hook (after-init . global-diff-hl-mode)
    :custom (diff-hl-draw-borders nil))
#+END_SRC
** Eglot
Use language servers in Emacs. Eglot is not quite "zero configuration," but it's
easy enough to set up. All-in-all it's a decent experience.

#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :bind (:map eglot-mode-map
                ("C-c ea" . eglot-code-actions)
                ("C-c ed" . flymake-show-project-diagnostics)
                ("C-c ef" . eglot-format-buffer)
                ("C-c er" . eglot-reconnect))
    :custom
    (eglot-autoshutdown t)
    (eglot-confirm-server-initiated-edits nil)
    (eglot-ignored-server-capabilities '(:inlayHintProvider))
    (jsonrpc-default-request-timeout 20))

  (use-package breadcrumb
    :hook (eglot-managed-mode . breadcrumb-local-mode))

  (use-package consult-eglot)
#+END_SRC
** Flymake
This built-in tool displays error messages via configurable sources. For me, the
sources are language servers.

#+BEGIN_SRC emacs-lisp
  (use-package flymake
    :bind (:map flymake-mode-map
                ([remap next-error] . flymake-goto-next-error)
                ([remap previous-error] . flymake-goto-prev-error))
    :custom
    (flymake-no-changes-timeout 1)
    (flymake-fringe-indicator-position 'right-fringe))
#+END_SRC
** TreeSitter
Abstract syntax tree based language parsing and syntax highlighting. This works
quite nicely, other than occasional breakage of the grammars.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :hook (after-init . r/remap-to-treesitter-modes)
    :custom (treesit-font-lock-level 4)
    :config (defun r/remap-to-treesitter-modes ()
              (mapc (lambda (remapping)
                      (add-to-list 'major-mode-remap-alist remapping))
                    '((c++-mode . c++-ts-mode)
                      (c-mode . c-ts-mode)
                      (css-mode . css-ts-mode)
                      (java-mode . java-ts-mode)
                      (javascript-mode . js-ts-mode)
                      (js-json-mode . json-ts-mode)
                      (mhtml-mode . html-ts-mode)
                      (sh-mode . bash-ts-mode)))))
#+END_SRC
** Shell
Interacting with the shell through Emacs is quite a bit nicer than via a
terminal emulator. For instance, there's no need to mess around with pagers if
you have all your Emacs facilities available. This workflow isn't really an
appropriate replacement for someone who uses ncurses-style or other fullscreen
terminal applications, but that person isn't me.

#+BEGIN_SRC emacs-lisp
  ;; Configure built-in `shell' and friends
  (use-package emacs
    :custom
    (async-shell-command-buffer 'new-buffer)
    (async-shell-command-display-buffer nil)
    (comint-scroll-to-bottom-on-output t)
    (compilation-scroll-output t))

  ;; Improvements to `shell-command' and friends.
  (use-package shell-command-x
    :hook (after-init . shell-command-x-mode))

  ;; Emulate A Terminal -> eat
  (use-package eat
    :hook (eshell-load . eat-eshell-mode)
    :custom (eat-enable-auto-line-mode t)
    :bind (:map eat-semi-char-mode-map
                ("," . nil)
                ("C-z" . nil)))

  (use-package emacs
    :hook (after-save . executable-make-buffer-file-executable-if-script-p))

  ;; Custom behaviors and tweaks
  (use-package emacs
    :bind ("C-c &" . r/sh-command-at-point)
    :config
    (defun r/sh-command-at-point ()
      "Run the command at point or in the selected region in the shell."
      (interactive)
      (async-shell-command
       (if (use-region-p)
           (buffer-substring (region-beginning) (region-end))
         (thing-at-point 'line t)))))
#+END_SRC
** Hideshow
Hideshow is built-in, but does not provide any straightforward way of folding
the (sometimes huge) list of imports that you find at the top of files for many
programming languages. This section configures a hacky workaround for that,
enabling import folding for certain filetypes. Code folding itself is a
secondary feature here; it does work, but I never use it.

#+BEGIN_SRC emacs-lisp
  (use-package hideshow
    :hook ((prog-mode . hs-minor-mode)
           (php-ts-mode . r/hs-fold-imports-lang)
           (java-ts-mode . r/hs-fold-imports-lang)
           (tsx-ts-mode . r/hs-fold-imports-lang)
           (typescript-ts-mode . r/hs-fold-imports-lang))
    :bind ("C-c <tab>" . hs-toggle-hiding)
    :config
    (defvar r/hs-fold-imports-alist
      '((php-ts-mode . "^use ")
        (java-ts-mode . "^import ")
        (tsx-ts-mode . "^import ")
        (typescript-ts-mode . "^import ")))

    (defun r/hs-fold-imports (pattern)
      (save-excursion
        (goto-char (point-min))
        (ignore-errors (re-search-forward pattern))
        (set-mark (point))
        (while (ignore-errors (re-search-forward pattern)))
        (ignore-errors (hs-hide-comment-region (region-beginning) (region-end)))
        (deactivate-mark t)))

    (defun r/hs-fold-imports-lang ()
      "Hide the initial block of import statements in a buffer of `major-mode'."
      (interactive)
      (r/hs-fold-imports
       (when (boundp 'r/hs-fold-imports-alist)
         (alist-get major-mode r/hs-fold-imports-alist)))))
#+END_SRC
** ElDoc
ElDoc is another nice built-in package that shows the user different kinds of
information in the echo area.

#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :custom
    (eldoc-echo-area-use-multiline-p nil)
    (eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly))

  (use-package eldoc-box :after eglot
    :bind (:map eglot-mode-map
                ("M-h" . eldoc-box-help-at-point))
    :config (add-to-list 'eldoc-box-self-insert-command-list
                         'scroll-other-window))
#+END_SRC
** Lisp
This section provides tools for interacting with Lisp interpreters and editing
Lisp code. The main difference between the Lisp editing experience and editing
other kinds of text is the Lispy package. Lispy provides some slick
functionality for manipulating Lisp code, but that power comes with some
caveats.

#+BEGIN_SRC emacs-lisp
  (use-package lispy
    :bind ((:map lispy-mode-map
                 ("C-<backspace>" . lispy-delete-backward))
           (:map lispy-mode-map-lispy
                 (":" . nil)))
    :hook ((lisp-mode . r/lispy-mode-maybe)
           (lisp-data-mode . r/lispy-mode-maybe)
           (scheme-mode . r/lispy-mode-maybe)
           (sly-mrepl-mode . r/lispy-mode-maybe)
           (emacs-lisp-mode . r/lispy-mode-maybe))
    :config (defun r/lispy-mode-maybe ()
              (r/enable-mode-maybe 'lispy-mode 1)))
#+END_SRC
*** Common Lisp

#+BEGIN_SRC emacs-lisp
  (use-package sly
    :config
    (setq sly-description-autofocus t)
    (setq sly-lisp-implementations
          '((sbcl ("sbcl") :coding-system utf-8-unix)
            (qlot ("qlot" "exec" "sbcl") :coding-system utf-8-unix))))

  (use-package sly-asdf
    :after sly
    :config (add-to-list 'sly-contribs 'sly-asdf 'append))
#+END_SRC
*** Emacs Lisp

#+BEGIN_SRC emacs-lisp
  (use-package highlight-defined
    :hook (emacs-lisp-mode . highlight-defined-mode))

  (use-package highlight-quoted
    :hook (emacs-lisp-mode . highlight-quoted-mode))
#+END_SRC
** PHP

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode ("\\.twig$" "\\.blade\\.php$"))

  ;; php base config
  (use-package php-ts-mode
    :mode "^[^.]+\\.php$"
    :hook ((php-ts-mode . eglot-ensure)
           (find-file . r/view-mode-in-vendor))
    :bind (:map php-ts-mode-map
                ("C-c ct" . r/php-test-current-file)
                ("C-c ss" . r/search-php-manual))
    :config
    (with-eval-after-load 'apheleia
      (setf (alist-get 'phpcs apheleia-formatters)
            '("composer" "--no-interaction"
              (concat "--working-dir=" (r/project-root))
              "exec" "php-cs-fixer" "fix" "--quiet" (buffer-file-name))))
    (defun r/php-test-current-file ()
      (interactive)
      (let ((default-directory (r/project-root)))
        (async-shell-command (format
                              "vendor/bin/phpunit %s"
                              (r/project-relative-path)))))
    (defun r/search-php-manual (query)
      "Search php.net for QUERY, defaulting to thing at point."
      (interactive
       (let ((thing (thing-at-point 'symbol t)))
         (list (read-string
                (if thing
                    (format "Query (default %s): " thing)
                  "Query: ")
                nil nil thing))))
      (browse-url
       (format "https://www.php.net/search.php#gsc.q=%s" query)))
    (defun r/view-mode-in-vendor ()
      (when (and buffer-file-name
                 (string-match-p "/vendor/" (expand-file-name buffer-file-name)))
        (view-mode))))

  ;; laravel stuff
  (use-package php-ts-mode
    :bind (:map php-ts-mode-map
                ("C-c cd" . r/laravel-debug-test-current-file))
    :config
    (defun r/laravel-test-command (type args)
      (let ((default-directory (r/project-root)))
        (async-shell-command
         (format "./sail %s test %s %s" type args (r/project-relative-path)))))
    (defun r/laravel-test-current-file ()
      (interactive)
      (r/laravel-test-command "artisan" "--ansi"))
    (defun r/laravel-debug-test-current-file ()
      (interactive)
      (r/laravel-test-command "debug" "--ansi"))
    (defun r/laravel-test-current-file-with-coverage ()
      (interactive)
      (r/laravel-test-command "artisan" "--ansi --coverage --coverage-html=\"build/coverage/report\""))
    (defun r/sail-artisan-model-show ()
      "If the currently visited buffer is an eloquent model, run sail artisan model:show on it."
      (interactive)
      (let ((default-directory (r/project-root))
            (file-name (file-name-base (buffer-file-name))))
        (async-shell-command (format "sail artisan model:show %s" file-name)))))
#+END_SRC
** Make
This code picks up all the targets from the nearest Makefile and lets you select
one of them to run as an ~async-shell-command~.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :bind ("C-c r" . r/make-run-target)
    :config
    (defun r/makefile-targets ()
      (let* ((makefile (locate-dominating-file default-directory "Makefile"))
             (makefile (expand-file-name "Makefile" makefile)))
        (when (and makefile (file-exists-p makefile))
          (flatten-list (with-current-buffer (find-file-noselect makefile t)
                          (makefile-pickup-targets)
                          makefile-target-table)))))
    (defun r/make-run-target ()
      (interactive)
      (let ((targets (r/makefile-targets)))
        (if targets
            (let ((target (completing-read "Make: " targets))
                  (default-directory (r/project-root)))
              (async-shell-command (format "make -k %s" target)
                                   (format "*Make: %s*" target)))
          (message "No Makefile targets found."))))

    ;; wip, not quite working yet
    (defun r/make-run-target-eat ()
      "Run a Makefile target using `eat-exec'. A keybinding is added for quitting the buffer."
      (interactive)
      (require 'eat)
      (let ((targets (r/makefile-targets)))
        (if targets
            (let* ((target (completing-read "Make: " targets))
                   (buf (get-buffer-create (format "*Make: %s*" target)))
                   (default-directory (r/project-root)))
              (with-current-buffer buf
                (use-local-map (copy-keymap eat-mode-map))
                (local-set-key (kbd "q") 'quit-window))
              (pop-to-buffer buf)
              (eat-exec buf (format "Make: %s" target) "make" nil (list "-k" target)))
          (message "No Makefile targets found.")))))
#+END_SRC
** Docker

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-ts-mode
    :mode ("Dockerfile$" "Containerfile$"))
#+END_SRC
** Java

#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :hook ((java-ts-mode . eglot-ensure)
           (java-ts-mode . visual-line-mode))
    :config
    (let* ((lombok-path (string-trim
                         (shell-command-to-string
                          "find ~/.m2 -type f -name 'lombok*.jar' | head -n 1")))
           (java-agent (concat "--jvm-arg=-javaagent:" lombok-path)))
      (setcdr (assoc '(java-mode java-ts-mode) eglot-server-programs)
              `("jdtls" ,java-agent)))
    (with-eval-after-load 'apheleia
      (setf (alist-get 'google-java-format apheleia-formatters)
            `("clang-format" "-assume-filename"
              ,(apheleia-formatters-local-buffer-file-name)))))

#+END_SRC
** C
#+BEGIN_SRC emacs-lisp
  (use-package c-ts-mode
    :hook ((c-ts-mode . eglot-ensure)
           (c++-ts-mode . eglot-ensure))
    :custom (c-ts-mode-indent-offset 4))
#+END_SRC
** Go
#+BEGIN_SRC emacs-lisp
  (use-package go-ts-mode
    :hook (go-ts-mode . eglot-ensure)
    :mode "\\.go$")
#+END_SRC
** JS/TS
The Javascript/Typescript landscape is a huge maze of both awesome and terrible
technology. This is how I interact with it.

#+BEGIN_SRC emacs-lisp
  (use-package dot-env)
  (use-package dotenv-mode
    :mode "\\.env\\.testing")

  (use-package js
    :custom (js-indent-level 2))

  (use-package typescript-ts-mode
    :mode "\\.ts$"
    :hook (typescript-ts-mode . eglot-ensure)
    :bind (:map typescript-ts-mode-map
                ("C-c ct" . r/js-ts-test-current-file))
    :config (defun r/js-ts-test-current-file ()
              (interactive)
              (let ((default-directory (r/project-root)))
                (async-shell-command (format "npm test %s"
                                             (r/project-relative-path))))))

  (use-package flymake-eslint
    :hook (eglot-managed-mode . r/flymake-eslint-enable-maybe)
    :config (defun r/flymake-eslint-enable-maybe ()
              (when (-any (lambda (mode) (eq major-mode mode))
                          '(typescript-ts-mode js-ts-mode))
                (flymake-eslint-enable))))
#+END_SRC
** LaTeX
Syntax highlighting and build tools for LaTeX.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :hook ((tex-mode . eglot-ensure)
           (tex-mode . display-line-numbers-mode)
           (tex-mode . visual-line-mode))
    :custom (bibtex-entry-format t)
    :config (defun r/latex-word-count ()
              (interactive)
              (shell-command
               (format "detex %s | wc" (buffer-file-name)))))
#+END_SRC
** Structured Text
Syntax highlighting for (non-org-mode) structured text. In practice, this means
yaml, markdown, and html.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :hook (markdown-mode . visual-line-mode)
    :custom ((markdown-hide-urls t)
             (markdown-hide-markup t)
             (markdown-fontify-code-blocks-natively t)
             (markdown-list-item-bullets '("●"))))

  (use-package yaml-mode
    :hook (yaml-mode . display-line-numbers-mode))

  (use-package yaml-pro
    :hook (yaml-mode . yaml-pro-ts-mode))

  (use-package emacs
    :hook ((css-ts-mode . display-line-numbers-mode)
           (html-ts-mode . display-line-numbers-mode)))
#+END_SRC
** Diagrams
#+BEGIN_SRC emacs-lisp
  (use-package plantuml-mode
    :custom (plantuml-indent-level 2))

  (use-package mermaid-mode)
#+END_SRC
** Natural language
Arguably one of the most important technologies of all.

#+BEGIN_SRC emacs-lisp
  ;; dictcc uses this function; generate autoload with use-package
  (use-package thingatpt
    :commands word-at-point)

  (use-package dictcc
    :custom (dictcc-completion-backend 'completing-read))
#+END_SRC
** Systemd
Syntax highlighting for unit files

#+BEGIN_SRC emacs-lisp
  (use-package systemd
    :mode ("\\.container$" . systemd-mode))
#+END_SRC
** LLM Assistants

#+BEGIN_SRC emacs-lisp
  (use-package copilot
    :unless (getenv "NO_COPILOT")
    :init (defvar r/copilot-available nil)
    :hook ((prog-mode . r/copilot-mode-maybe)
           (markdown-mode . r/copilot-mode-maybe))
    :bind ("C-<tab>" . copilot-accept-completion)
    :custom (copilot-idle-delay 0.5)
    :config
    (defun r/copilot-mode-maybe ()
      (if r/copilot-available
          (r/enable-mode-maybe 'copilot-mode 1)
        (when (executable-find "npm")
          (make-process
           :name "copilot-check"
           :buffer nil
           :command '("npm" "list" "-g" "@github/copilot-language-server")
           :noquery t
           :sentinel
           (lambda (proc event)
             (when (and (memq (process-status proc) '(exit signal))
                        (= (process-exit-status proc) 0))
               (r/enable-mode-maybe 'copilot-mode 1)
               (setq r/copilot-available t))))))))

  (use-package gptel
    :hook (after-init . r/configure-gptel)
    :bind (("C-c cg" . gptel-menu)
           (:map gptel-mode-map
                 ("C-c C-c" . gptel-send)))
    :custom ((gptel-gh-github-token-file (expand-file-name "var/cache/github-token" user-emacs-directory))
             (gptel-gh-token-file (expand-file-name "var/cache/token" user-emacs-directory)))
    :config (defun r/configure-gptel ()
              (setq gptel-model 'gpt-5-mini)
              (setq gptel-backend (gptel-make-gh-copilot "Copilot"))))
#+END_SRC
* UI
This section enables themes, tweaks font faces, adds icons, etc. This section is
not as important as the actual functionality and should be considered a layer of
"nice to have" stuff that could be easily disabled all at once for a
hypothetical terminal-only workflow.

** Eye Candy
This stuff isn't really necessary, but it looks cool.

#+BEGIN_SRC emacs-lisp
  ;; briefly overlay results of `eval-last-sexp' in the buffer
  (use-package eros
    :hook (after-init . eros-mode)
    :custom-face
    (eros-result-overlay-face
     ((t ( :background unspecified :inherit region :box t)))))

  ;; Briefly flash current line in certain situations
  (use-package pulsar
    :hook (after-init . pulsar-global-mode)
    :config (setq pulsar-pulse-functions
                  (append '(avy-goto-char-timer
                            flymake-goto-next-error
                            flymake-goto-prev-error
                            isearch-repeat-backward
                            isearch-repeat-forward)
                          pulsar-pulse-functions))
    :custom (pulsar-pulse-region-functions
             pulsar-pulse-region-common-functions))

  ;; Highlight TODO items in buffers
  (use-package hl-todo
    :hook (prog-mode . hl-todo-mode))

  (use-package page-break-lines
    :hook (after-init . global-page-break-lines-mode)
    :config (add-to-list 'page-break-lines-modes 'emacs-news-view-mode))

  (use-package olivetti
    :bind ("C-c to" . olivetti-mode)
    :custom (olivetti-style t))

  (use-package rainbow-mode)
#+END_SRC
** Icons
Shows icons via some special icon fonts.

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :config (setq all-the-icons-color-icons nil))

  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))
#+END_SRC
** Project Drawer
Project browser with multiple-root functionality.

#+BEGIN_SRC emacs-lisp
  (use-package treemacs-all-the-icons
    :commands r/treemacs-all-the-icons
    :config (defun r/treemacs-all-the-icons ()
              (treemacs-load-theme "all-the-icons")))

  (use-package treemacs
    :hook ((treemacs-mode . r/treemacs-all-the-icons)
           (treemacs-mode . (lambda ()
                              (setq-local truncate-lines t)))))
#+END_SRC
** Faces

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :hook ((after-init . r/fix-fontsets)
           (org-mode . r/fix-fontsets))
    :config
    (defun r/fix-fontsets ()
      (set-fontset-font t 'symbol "Noto Emoji" nil 'prepend)
      (set-fontset-font t 'unicode "JuliaMono" nil 'prepend))
    :custom-face
    (default
     ((t (:height 100))))
    (fringe
     ((t (:background unspecified))))
    (variable-pitch
     ((t (:family unspecified))))
    (fixed-pitch
     ((t (:family unspecified))))

    (header-line
     ((t (:box (:line-width 3 :style flat-button)))))
    (mode-line
     ((t (:box (:line-width 3 :style flat-button)))))
    (mode-line-inactive
     ((t (:box (:line-width 3 :style flat-button)))))

    (help-key-binding
     ((t ( :foreground unspecified
           :background unspecified
           :box unspecified
           :bold t))))

    (info-menu-star
     ((t (:inherit unspecified :foreground unspecified)))))
#+END_SRC
** Themes
A good theme can make editing even more fun. Since themes are essentially just a
collection of face settings, often with intricate logic for enabling them, this
section is tightly connected with the [[*Faces][Faces]] section.

#+BEGIN_SRC emacs-lisp
  (use-package auto-dark
    :hook (after-init . auto-dark-mode)
    :custom (auto-dark-themes '((modus-vivendi)
                                (modus-operandi))))

  (use-package emacs
    :custom (modus-vivendi-palette-overrides
             '((bg-main "#1D1D20")
               (bg-dim "#191920")))
    :config
    (defun r/load-theme (theme)
      "Wrapper for loading themes."
      (mapc #'disable-theme custom-enabled-themes)
      (load-theme theme t))

    (defun r/dark-mode ()
      "Switch to dark mode, featuring `modus-vivendi' theme."
      (interactive)
      (r/load-theme 'modus-vivendi))

    (defun r/light-mode ()
      "Switch to light mode, featuring `modus-operandi' theme."
      (interactive)
      (r/load-theme 'modus-operandi)))
#+END_SRC
* Machine Specific Tweaks
This section is reserved for whatever configuration that might occur that only
applies to one specific machine. Keeping this config in a separate repository
and symlinking it into this directory seems like the cleanest approach.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :config (load (locate-user-emacs-file
                   "local-config.el")
                  'noerror))
#+END_SRC

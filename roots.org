#+TITLE: Roots
#+DATE: 2024
#+PROPERTY: header-args :tangle init.el
#+STARTUP: overview


* Usage
** Philosophy
Less is more. If there are feasible built-in options, use those. Streamline
repetitive configuration with wrapper functions. Document design
decisions. Enable modes in a more granular fashion. Use hooks wisely.

** Tangling
This file must be tangled or otherwise loaded with the help of ~org-babel~ in
order to activate any of the configuration contained within it. This can be
easily done from the root of this repository with ~make retangle~.

** Lazy Loading
The argument for lazy loading is mostly taken from the [[info:use-package#Deferring loading][Deferring loading]] section
of the ~use-package~ manual. This config attempts to be "strict" about lazy
loading; packages will be loaded lazily by default according to
~use-package-always-defer~ (See the ~use-package~ setup in ~early-init.el~.). The
~use-package~ manual describes how to leverage its features for this purpose, but
one of the simplest approaches that can be immediately applied to many packages
is using ~:hook~ to enable modes instead of just calling them. Compare:

#+BEGIN_SRC emacs-lisp :tangle no
  ;; Immediately loads the package
  (use-package which-key
    :config (which-key-mode))

  ;; Defers loading
  (use-package which-key
    :hook (after-init . which-key-mode))
#+END_SRC

This can also be useful for removing the startup penalty involved in changing
Emacs' default settings; doing that is basically just yak shaving though because
the code still has to be loaded /somehow/. Still, changing built-in settings in a
function via ~after-init-hook~ can shave a few milliseconds off of the init time.

* Basic Setup
This section defines what I consider "sane defaults;" there are so many
variations of that idea out there that I doubt my opinions here are needed; just
try it and see if you like it.

** Lexical Binding
For a discussion on what lexical binding is, and why this is
necessary, see the [[info:elisp#Variable Scoping][Variable Scoping]] node in the manual.

#+BEGIN_SRC emacs-lisp
  ;;; -*- lexical-binding: t -*-
  ;; This file is generated with `org-babel'. See the accompanying file
  ;; `roots.org' for the rationale behind the code.
#+END_SRC

** Warnings
Most of these warnings need to be fixed by package developers; I guess I could
leave them on and submit a bug report to the authors, but I don't have time for
that. As an end-user, I don't want to see them.

#+BEGIN_SRC emacs-lisp
  (setq native-comp-async-report-warnings-errors nil)
  (setq warning-suppress-log-types '((comp) (bytecomp)))
  (setq warning-minimum-level :error)
#+END_SRC

** Utility Functions
This is where I define any functions that I want available from the start of the
init file.

#+BEGIN_SRC emacs-lisp
  ;; Places where this would be useful were identified with `esup'.
  (defun r/run-idly (function seconds)
    "Run the no-arg `function' after `seconds' of idle time."
    (run-with-idle-timer
     seconds nil function))

  (defun r/face-filter (regex)
    "Return a list of faces matching `regex'."
    (cl-remove-if-not
     (lambda (s) (string-match-p regex (symbol-name s)))
     (face-list)))
#+END_SRC

** Editor Defaults
These settings are essentially subjective, but serve to disable some annoyances
(lockfiles, audible bell) or improve ergonomics (~TAB~ for completion instead of
~C-M-i~, ~winner-mode~).

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :hook (after-init . r/set-defaults)
    :config
    (defun r/set-defaults ()
      ;; By using `fundamental-mode' as the initial major mode, we're deferring
      ;; loading of `prog-mode' and some of its derivatives when starting up
      (setq inhibit-startup-screen t)
      (setq initial-major-mode 'fundamental-mode)
      (setq initial-scratch-message nil)

      ;; Avoid/streamline interactive questions.
      (defalias 'yes-or-no-p 'y-or-n-p)
      (setq confirm-kill-processes nil)
      (setq use-dialog-box nil)

      ;; Don't create backup/lockfiles.
      ;; This is the 21st century; we have git.
      (setq create-lockfiles nil)
      (setq make-backup-files nil)

      ;; `folder/filename' instead of `filename<2>'
      (setq uniquify-buffer-name-style 'forward)

      ;; Line style and indentation
      (setq-default indent-tabs-mode nil)
      (setq-default truncate-lines t)
      (setq-default fill-column 80)
      (setq require-final-newline t)

      ;; Scrolling
      (setq scroll-conservatively 101)
      (setq auto-hscroll-mode 'current-line)

      ;; Minibuffer
      (setq enable-recursive-minibuffers t)
      (setq max-mini-window-height 8)

      ;; Miscellaneous improvements
      (setq tab-always-indent 'complete)
      (setq Man-notify-method 'pushy)
      (setq ring-bell-function 'ignore)
      (setq frame-resize-pixelwise t)
      (setq line-spacing 0.1)))

  ;; The default UX when using `visual-line-mode' without line numbers
  ;; isn't great; this package indents wrapped lines to make it clearer
  ;; that they've been wrapped.
  (use-package adaptive-wrap
    :hook (visual-line-mode . adaptive-wrap-prefix-mode)
    :config (setq adaptive-wrap-extra-indent 3))

  ;; Commands
  (use-package emacs
    :hook
    (after-init . repeat-mode)
    (after-init . r/enable-commands)
    :config
    (defun r/enable-commands ()
      (put 'narrow-to-region 'disabled nil)
      (put 'downcase-region 'disabled nil)
      (put 'upcase-region 'disabled nil)
      (put 'scroll-left 'disabled nil)
      (put 'scroll-right 'disabled nil)))

  ;; Take control over windows; C-c <left> and C-c <right> to go back
  ;; and forth in the window history.
  (use-package emacs
    :hook (after-init . winner-mode)
    :bind (("C-c wu" . winner-undo)
           ("C-c wr" . winner-redo)))

  ;; This is much more useful than `iconify-frame'; in the terminal this
  ;; might be a problem, but I never use Emacs in the terminal anyways.
  (use-package emacs
    :bind ("C-z" . bury-buffer))

  ;; Follow newly split windows
  (use-package emacs
    :bind (("C-c wv" . r/split-right)
           ("C-c ws" . r/split-below))
    :config
    (defun r/split-direction (direction)
      (funcall direction)
      (other-window 1))
    (defun r/split-below ()
      "Split window below and follow."
      (interactive)
      (r/split-direction #'split-window-below))
    (defun r/split-right ()
      "Split window right and follow."
      (interactive)
      (r/split-direction #'split-window-right)))
#+END_SRC

** Line Numbers
Some say that line numbers are something of an anti-pattern in Emacs, but
~display-line-numbers-mode~ doesn't seem to have an appreciable performance impact
and it's very helpful when discussing code with colleagues.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :hook
    (prog-mode . display-line-numbers-mode)
    (display-line-numbers-mode . hl-line-mode)
    :config
    (setq display-line-numbers-grow-only t)
    (setq-default display-line-numbers-width 3)
    (setq-default display-line-numbers-widen t))
  #+END_SRC

** History
Keeping track of where you've been and the things you've done is an incredible
time saver.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :hook
    (after-init . recentf-mode)
    (after-init . save-place-mode)
    (after-init . savehist-mode)
    (after-init . r/configure-history)
    :config
    (defun r/configure-history ()
      (with-eval-after-load 'recentf
        (setq recentf-max-saved-items 200)
        (add-to-list 'recentf-exclude '("\\/sudo:root@localhost.*"))
        (run-at-time nil (* 5 60) 'recentf-save-list))
      (setq savehist-additional-variables
            '(file-name-history
              search-ring
              command-history
              regexp-search-ring))))
#+END_SRC

** Modeline
The default modeline works well enough; I simply enable a few more bits of
information for it to show.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :hook (after-init . r/modeline-info)
    :config
    ;; Don't waste space in the modeline showing me the version control
    ;; status.
    (setq-default mode-line-format
                  (delete '(vc-mode vc-mode)
                          mode-line-format))

    (defun r/modeline-info ()
      (setq battery-mode-line-format "[%b%p%%] ")
      (setq datetime-timezone 'Europe/Vienna)
      (setq display-time-24hr-format 1)
      (setq display-time-format "[%H:%M] ")
      (setq display-time-default-load-average nil)
      (display-battery-mode)
      (display-time-mode)
      (column-number-mode))

    (defun r/echo-modeline ()
      "Show the current mode line in the minibuffer. The minibuffer will
  grow to fit the whole thing, so any time information is out of
  view on the right fringe, call this function to see the rest."
      (interactive)
      (message "%s" (format-mode-line mode-line-format))))
#+END_SRC

** Dired
Dired is the greatest file manager ever created. The existence of ~wdired~ alone
makes it superior to any graphical file manager I've ever seen; add on
everything else dired is capable of, and there's just no contest.

#+BEGIN_SRC emacs-lisp
  (use-package dired
    :ensure nil
    :hook
    (dired-mode . dired-hide-details-mode)
    (dired-mode . auto-revert-mode)
    (after-init . (lambda () (load "dired-x")))
    :bind (:map dired-mode-map
                ("C-c C-e" . wdired-change-to-wdired-mode))
    :config
    (setq dired-listing-switches "-alh --group-directories-first")
    (setq dired-dwim-target t)
    (setq dired-clean-up-buffers-too nil))

  ;; Add some color to dired
  (use-package diredfl
    :hook (after-init . diredfl-global-mode))

  ;; This package lets you show subfolders in a tree view instead of
  ;; inserting them below. It's very slow on deeply nested directories,
  ;; so use it carefully.
  (use-package dired-subtree
    :vc (:fetcher github :repo Fuco1/dired-hacks)
    :commands r/dired-subtree-face-override
    :hook
    ;; HACK: for some reason, using `:bind' doesn't work consistently for this
    (dired-mode
     . (lambda () (bind-key [tab] #'dired-subtree-cycle 'dired-mode-map)))
    :config
    (defun r/dired-subtree-face-override ()
      (interactive)
      (with-eval-after-load 'org-faces
        (let ((facelist (r/face-filter "^dired-subtree-")))
          (dolist (face facelist)
            (set-face-attribute face nil :extend t :background 'unspecified))))))
#+END_SRC

** Calendar
All I really want in a calendar is to see the days of the month and the week
numbers. This thing does that beautifully, and it's right here.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    ;; Always highlight today if it's visible
    :hook (calendar-today-visible . calendar-mark-today)
    :config
    (setq calendar-week-start-day 1)
    ;; Show week numbers
    (setq calendar-intermonth-text
          '(propertize
            (format "%2d"
                    (car
                     (calendar-iso-from-absolute
                      (calendar-absolute-from-gregorian (list month day year)))))
            'font-lock-face 'font-lock-keyword-face)))
#+END_SRC

** Directories
Emacs normally fails to perform a file operation when trying to write or copy
files into directories which do not yet exist. This behavior is almost never
helpful; instead, if I'm working in the minibuffer and explicitly say to put a
file into a directory which does not yet exist, I mean that the directory should
be created and the file should be put there. This sort of DWIM behavior is
surprisingly lacking by default. This section fixes that oversight.

#+BEGIN_SRC emacs-lisp
  ;; Make missing directories instead of uselessly failing.
  (defun r/make-directory-if-not-exists (filename)
    "Create parent directory if not exists while operating on `FILENAME'."
    (unless (file-exists-p filename)
      (let ((dir (file-name-directory filename)))
        (unless (file-exists-p dir)
          (make-directory dir t)))))

  ;; TODO figure out how to do this with less duplication
  (defun r/advise-file-operations ()
    (defadvice find-file (before make-directory-maybe (filename &optional wildcards) activate)
      (r/make-directory-if-not-exists filename))
    (defadvice copy-file (before make-directory-maybe (file newname &optional ok-if-already-exists keep-time preserve-uid-gid preserve-permissions) activate)
      (r/make-directory-if-not-exists newname))
    (defadvice rename-file (before make-directory-maybe (file newname &optional ok-if-already-exists) activate)
      (r/make-directory-if-not-exists newname)))

  (r/run-idly #'r/advise-file-operations 1)
#+END_SRC

** Informational
This section provides informational improvements to the default user experience.

#+BEGIN_SRC emacs-lisp
  ;; Improvements for help commands.
  (use-package helpful
    :bind (("C-h f" . helpful-callable)
           ("C-h v" . helpful-variable)
           ("C-h k" . helpful-key)))

  ;; Make ibuffer a little more user-friendly by categorizing buffers into projects
  (use-package ibuffer-project
    :hook (ibuffer . r/ibuffer-project)
    :config
    (defun r/ibuffer-project ()
      (setq ibuffer-filter-groups (ibuffer-project-generate-filter-groups))
      (unless (eq ibuffer-sorting-mode 'project-file-relative)
        (ibuffer-do-sort-by-project-file-relative))))

  ;; Show next possible keys after a short delay.
  (use-package which-key
    :hook (after-init . which-key-mode))
#+END_SRC

** Ergonomics
This section sets up some ergonomic packages. [[https://susam.github.io/devil/][Devil]] mode allows you to use the
comma key as the ~C-~ and ~M-~ prefixes prevalent in Emacs keychords. It freely
translates sequences like ~, x , f~ or ~, m x~ into the equivalent ~C-x C-f~ and ~M-x~
respectively. The best part is that it does not interfere with normal
keybindings and it works in the minibuffer. Crux is a package containing lots of
great functions that you might otherwise end up writing yourself.

#+BEGIN_SRC emacs-lisp
  (use-package devil
    :hook (after-init . global-devil-mode)
    :config (setq devil-all-keys-repeatable t))

  (use-package crux
    :bind (("C-M-j" . crux-top-join-line)
           ("C-M-k" . crux-kill-whole-line)
           ("C-c D" . crux-duplicate-current-line-or-region)
           ("C-c U" . crux-upcase-region)
           ("C-c L" . crux-downcase-region)
           ("C-c cu" . crux-sudo-edit)))

  ;; Jump anywhere quickly; C-' to activate, then type a few letters.
  (use-package avy
    :bind ("C-'" . avy-goto-char-timer)
    :config (setq avy-all-windows t))

  ;; Switch quickly between more than two active windows.
  (use-package iwindow
    :bind ("C-x o" . iwindow-select)
    :config
    (setq iwindow-selection-keys
          '(97 115 100 102 103 104 106 107 108))
    :custom-face
    (iwindow-highlight-default
     ((t ( :background unspecified
           :inherit hl-line)))))

  ;; Automatically close parentheses/quotes etc.
  (use-package elec-pair
    :hook (prog-mode . electric-pair-mode))
#+END_SRC

** Buffer Display
Have a look at [[https://www.masteringemacs.org/article/demystifying-emacs-window-manager][this chapter of Mastering Emacs]] for a deep dive into how these
settings work. I find that most windows that I interact with are either used
only briefly, or are dedicated to some specific task that requires full
attention. I don't want to deal with the slight interruption of flow that occurs
when I open a help window and then have to explicitly switch to it in order to
follow a documentation link or something like that. Splitting windows is not the
right approach for these use cases in my opinion; hence this block that
specifies some windows that should replace ~current-buffer~ in the window that I'm
already working in.

#+BEGIN_SRC emacs-lisp
  ;; This variable specifies which buffers should be opened in the
  ;; active window instead of popping up off to one side. Some of these
  ;; apply to packages that are loaded later in the config.
  (setq r/buffer-regexes '("\\*Help" "\\*helpful" "^magit:" "^*shell:"))

  (defun r/display-buffer-same-window (regex)
    "Set the buffer name pattern specified by `regex' to be opened in
  the active window."
    (add-to-list 'display-buffer-alist
                 `(,regex (display-buffer-same-window))))

  (dolist (regex r/buffer-regexes)
    (r/display-buffer-same-window regex))
#+END_SRC

** Search
Searching text is split between these kinds of dedicated packages and consult.

#+BEGIN_SRC emacs-lisp
  ;; Improves isearch without unexpected behavioral changes
  (use-package ctrlf
    :hook (after-init . ctrlf-mode)
    :config (setq ctrlf-auto-recenter t))

  ;; Nice search package with a clear and powerful interface.
  (use-package deadgrep
    :config
    ;; HACK: this does work, but it's not that nice. Starting a search
    ;; explicitly via `deadgrep' works better.
    (defun r/embark-become-deadgrep (&optional full)
      (interactive "P")
      (unless (minibufferp)
        (user-error "Not in a minibuffer"))
      (let* ((target (embark--display-string ; remove invisible portions
                      (if full
                          (minibuffer-contents)
                        (pcase-let ((`(,beg . ,end) (embark--boundaries)))
                          (string-remove-prefix
                           "#" (substring (minibuffer-contents) beg
                                          (+ end (embark--minibuffer-point)))))))))
        (embark--become-command #'deadgrep target)))
    :bind (:map minibuffer-mode-map
                ("C-c C-d" . r/embark-become-deadgrep)))

  (use-package xref
    :bind (:map prog-mode-map
                ("M-/" . xref-find-references)))

  ;; Edit grep results like they were a normal buffer.
  (use-package wgrep
    :after embark
    :bind (:map embark-collect-mode-map
                ("C-c C-p" . wgrep-change-to-wgrep-mode))
    :config (setq wgrep-auto-save-buffer t))

  (use-package wgrep-deadgrep
    :after deadgrep
    :config
    (defun deadgrep-edit-mode ()
      (interactive)
      (wgrep-change-to-wgrep-mode)))
#+END_SRC

* Minibuffer and Completion Interaction Overhaul (MOVECC)
These packages work together as building blocks to extend default Emacs input
scenarios in impressive ways. This includes overhauling minibuffer and
completion interaction. ~MOVECC~ is just a halfway usable acronym for referring to
this package stack.

** Marginalia
Marginalia adds information to minibuffer completion candidates.

#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :hook (after-init . marginalia-mode))
#+END_SRC

** Orderless
The orderless completion style allows for more powerful and intuitive matching
on completion candidates.

#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :hook (after-init . r/setup-orderless)
    :config
    (defun r/setup-orderless ()
      (setq completion-styles '(orderless basic))
      (setq completion-category-defaults nil)
      (setq completion-category-overrides '((file) (styles partial-completion)))))
#+END_SRC

** Vertico
Vertico hooks into ~completing-read~ to provide a powerup for interacting with the
minibuffer. Everywhere the user might be prompted for some kind of input,
vertico is there to make it better. The only really "unique" part of my setup of
this package is ~r/vertico-highlight-file-base-name~; this function adds color to
the "base name" of files, but only when completing candidates with
~project-file~. What this means concretely is that if a candidate looks like
~some/super/long/path/to/file.el~, the part ~file.el~ will be a different color.

#+BEGIN_SRC emacs-lisp
  (use-package vertico
    :hook (after-init . vertico-mode)
    :custom-face
    (vertico-group-title
     ((t ( :inherit font-lock-comment-face))))
    :config
    (vertico-multiform-mode)

    (defvar +vertico-transform-functions nil)

    (cl-defmethod vertico--format-candidate :around
      (cand prefix suffix index start &context ((not +vertico-transform-functions) null))
      (dolist (fun (ensure-list +vertico-transform-functions))
        (setq cand (funcall fun cand)))
      (cl-call-next-method cand prefix suffix index start))

    (defun r/vertico-highlight-file-base-name (file)
      "If FILE is a relative path with directory components, highlight only the base filename."
      (if (and (string-match "/" file) (not (string-suffix-p "/" file)))
          (progn (add-face-text-property
                  (length (file-name-directory file)) (length file)
                  'font-lock-type-face nil file)
                 file)
        file))

    (add-to-list 'vertico-multiform-categories
                 '(project-file (+vertico-transform-functions . r/vertico-highlight-file-base-name)))

    (setq vertico-cycle t)
    (setq vertico-count 12)
    (setq vertico-resize nil))

  (use-package vertico-directory
    :after vertico
    :ensure nil
    :bind (:map vertico-map
                ("RET" . vertico-directory-enter)
                ("DEL" . vertico-directory-delete-char))
    :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))
#+END_SRC

** Embark
Embark is essentially a keyboard-driven right-click menu, but with all of the
power and extensibility that Emacs Lisp offers. The fact that it works
seamlessly in the minibuffer is the cherry on top of an already very useful
package.

#+BEGIN_SRC emacs-lisp
  (use-package embark
    :bind (("C-;" . embark-act)
           :map minibuffer-local-map
           ("C-'" . embark-act-all)
           ("C-c C-e" . embark-export))
    :config
    (setq embark-indicators '(embark-minimal-indicator))
    (setq embark-prompter 'embark-completing-read-prompter))
#+END_SRC

** Consult
This package provides many nice functions for streamlining/enabling a smooth
minibuffer workflow. It covers a lot of use cases, and the way I use it is just
one (very) small subset of the possibilities it offers. I have added two wrapper
functions for some default consult commands due to the fact that they
misleadingly (that is, the docstrings don't mention this) use the current
project as detected with ~project.el~ instead of ~default-directory~. I don't
normally want this, especially in large projects.

#+BEGIN_SRC emacs-lisp
  (use-package consult
    :bind (("C-x b" . consult-buffer)
           ("C-x pr" . consult-ripgrep)
           ("C-c cr" . r/consult-rg-current-directory)
           ("C-c cf" . r/consult-fd-current-directory)
           ("C-c cl" . consult-line)
           ("C-\\" . consult-line)
           ("M-g i" . consult-imenu))
    :config
    (setq xref-show-xrefs-function 'consult-xref)
    (setq xref-show-definitions-function 'consult-xref)

    (defun r/consult-rg-current-directory ()
      (interactive)
      (consult-ripgrep default-directory))
    (defun r/consult-fd-current-directory ()
      (interactive)
      (consult-fd default-directory)))

  (use-package consult-dir
    :bind (:map minibuffer-mode-map
                ("C-M-d" . consult-dir)))

  (use-package embark-consult)
#+END_SRC

** Corfu
Corfu provides a popup completion menu that works with default completions,
similarly to vertico. My config is intended to be driven entirely via ~TAB~; it
worked better when I used evil, and I haven't gotten around to making it work
nicely with ~C-f~, ~C-b~, etc.

#+BEGIN_SRC emacs-lisp
  (use-package corfu
    :hook
    (after-init . global-corfu-mode)
    (minibuffer-setup . corfu-enable-in-minibuffer)
    (eglot-managed-mode . corfu-popupinfo-mode)
    :bind (:map corfu-map
                ("TAB" . corfu-next)
                ([tab] . corfu-next)
                ("S-TAB" . corfu-previous)
                ([backtab] . corfu-previous))
    :config
    (setq corfu-cycle t)
    (setq corfu-max-width 80)
    (setq corfu-auto t)
    (setq corfu-auto-delay 0.5)
    (setq corfu-preselect 'prompt)
    (defun corfu-enable-in-minibuffer ()
      "Enable Corfu in the minibuffer if `completion-at-point' is bound."
      (when (where-is-internal #'completion-at-point (list (current-local-map)))
        (setq-local corfu-echo-delay nil
                    corfu-popupinfo-delay nil)
        (corfu-mode 1))))
#+END_SRC

* Technologies
Up until this point, the configuration has been solely related to building up
the platform in which my workflow occurs. This section provides configuration
for specific technologies such as programming languages and corresponding
language servers.

** General Purpose
This section enables some tools which are generally useful for manipulating
text.

#+BEGIN_SRC emacs-lisp
  ;; Enclose regions with (), [], {}, etc.
  (use-package wrap-region
    :hook (after-init . wrap-region-mode))

  ;; Faster/more interactive way of doing
  ;; `query-replace-regex'
  (use-package iedit
    :bind ("C-." . iedit-mode))

  (use-package string-inflection)

  ;; cleanup stray whitespace on save
  (use-package ws-butler
    :hook (prog-mode . ws-butler-mode))

  ;; Reformat buffers when needed
  (use-package apheleia
    :hook (prog-mode . apheleia-mode))
#+END_SRC

** Shell
Interacting with the shell through Emacs is quite a bit nicer than via a
terminal emulator. For instance, there's no need to mess around with pagers if
you have all your Emacs facilities available. This workflow isn't really an
appropriate replacement for someone who uses ncurses-style or other fullscreen
terminal applications, but that person isn't me.

#+BEGIN_SRC emacs-lisp
  ;; Improvements to `shell-command' and friends.
  (use-package shell-command-x
    :hook (after-init . shell-command-x-mode))

  ;; Emulate A Terminal -> eat
  (use-package eat
    :bind (:map eat-semi-char-mode-map
                ("," . nil))
    :commands eat-compile-terminfo
    :config (setq eat-enable-auto-line-mode t))

  ;; Configurable command recipes
  (use-package run-command
    :bind ("C-c C-r" . run-command)
    :config (setq run-command-default-runner 'run-command-runner-eat))

  ;; Automatically set shell scripts to executable when saving
  (use-package emacs
    :hook (after-save . executable-make-buffer-file-executable-if-script-p))

  ;; Configure built-in `comint' mode
  (use-package emacs
    :config (setq comint-scroll-to-bottom-on-output t))

  (use-package emacs
    :bind ("C-c &" . r/sh-command-at-point)
    :config
    (defun r/sh-command-at-point ()
      "Run the command at point or in the selected region in the shell."
      (interactive)
      (async-shell-command
       (if (use-region-p)
           (buffer-substring (region-beginning) (region-end))
         (thing-at-point 'line t)))))

  ;; Fix ansi color codes in compilation buffers
  (use-package emacs
    :hook (compilation-filter . r/ansi-colorize-buffer)
    :config
    (defun r/ansi-colorize-buffer ()
      (let ((buffer-read-only nil))
        (ansi-color-apply-on-region (point-min) (point-max)))))
#+END_SRC

** Git
Although Emacs does come with a built-in interface to version control, it's
cumbersome and inelegant compared to Magit. This section sets up Magit and a few
other utility packages related to git.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :config (setq magit-display-buffer-function 'display-buffer))

  ;; Show previous versions of a file
  (use-package git-timemachine)

  ;; Display git blame for the current line
  (use-package why-this
    :custom-face
    (why-this-face
     ((t ( :foreground unspecified
           :inherit font-lock-comment-face)))))
#+END_SRC

** Make
So far the only configuration I need for ~make~ is a ~run-command~ recipe. Emacs
otherwise does a great job out-of-the-box. This recipe is one I wrote myself.

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'run-command

    (defun run-command-recipe-make ()
      "Provide commands to run Makefile targets."
      (require 'make-mode)
      (when-let* ((project-dir
                   (locate-dominating-file default-directory "Makefile"))
                  (makefile (concat project-dir "Makefile"))
                  (targets (mapcar #'car (with-current-buffer
                                             (find-file-noselect makefile t)
                                           (setq makefile-need-target-pickup t)
                                           (makefile-pickup-targets)
                                           makefile-target-table))))
        (seq-map
         (lambda (target)
           (list
            :command-name target
            :command-line (concat "make " target)
            :display target
            :working-dir project-dir))
         targets)))

    (add-to-list 'run-command-recipes 'run-command-recipe-make))
#+END_SRC

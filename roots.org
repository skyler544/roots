#+TITLE: Roots
#+DATE: 2024
#+PROPERTY: header-args :tangle init.el
#+STARTUP: overview


* Usage
** Tangling
This file must be tangled or otherwise loaded with the help of ~org-babel~ in
order to activate any of the configuration contained within it. This can be
easily done from the root of this repository with ~make retangle~.

** Lazy Loading
The argument for lazy loading is mostly taken from the [[info:use-package#Deferring loading][Deferring loading]] section
of the ~use-package~ manual. This config attempts to be "strict" about lazy
loading; packages will be loaded lazily by default according to
~use-package-always-defer~ (See the ~use-package~ setup in ~early-init.el~.). The
~use-package~ manual describes how to leverage its features for this purpose, but
one of the simplest approaches that can be immediately applied to many packages
is using ~:hook~ to enable modes instead of just calling them. Compare:

#+BEGIN_SRC emacs-lisp :tangle no
  ;; Immediately loads the package
  (use-package which-key
    :config (which-key-mode))

  ;; Defers loading
  (use-package which-key
    :hook (after-init . which-key-mode))
#+END_SRC

This can also be useful for removing the startup penalty involved in changing
Emacs' default settings; doing that is basically just yak shaving though because
the code still has to be loaded /somehow/. Still, changing built-in settings in a
function via ~after-init-hook~ can shave a few milliseconds off of the init time.

* Basic Setup
This section defines what I consider "sane defaults;" there are so many
variations of that idea out there that I doubt my opinions here are needed; just
try it and see if you like it.

** Lexical Binding
For a discussion on what lexical binding is, and why this is
necessary, see the [[info:elisp#Variable Scoping][Variable Scoping]] node in the manual.

#+BEGIN_SRC emacs-lisp
  ;;; -*- lexical-binding: t -*-
  ;; This file is generated with `org-babel'. See the accompanying file
  ;; `roots.org' for the rationale behind the code.
#+END_SRC

** Warnings
Most of these warnings need to be fixed by package developers; I guess I could
leave them on and submit a bug report to the authors, but I don't have time for
that. As an end-user, I don't want to see them.

#+BEGIN_SRC emacs-lisp
  (setq native-comp-async-report-warnings-errors nil)
  (setq warning-suppress-log-types '((comp) (bytecomp)))
  (setq warning-minimum-level :error)
#+END_SRC

** Utility Functions
This is where I define any functions that I want available from the start of the
init file.

#+BEGIN_SRC emacs-lisp
  ;; Places where this would be useful were identified with `esup'.
  (defun r/run-idly (function seconds)
    "Run the no-arg `function' after `seconds' of idle time."
    (run-with-idle-timer
     seconds nil function))

  (defun r/face-filter (regex)
    "Return a list of faces matching `regex'."
    (cl-remove-if-not
     (lambda (s) (string-match-p regex (symbol-name s)))
     (face-list)))
#+END_SRC

** Editor Defaults
These settings are essentially subjective, but serve to disable some annoyances
(lockfiles, audible bell) or improve ergonomics (~TAB~ for completion instead of
~C-M-i~).

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :hook (after-init . r/set-defaults)
    :config
    (defun r/set-defaults ()
      ;; By using `fundamental-mode' as the initial major mode, we're deferring
      ;; loading of `prog-mode' and some of its derivatives when starting up
      (setq inhibit-startup-screen t)
      (setq initial-major-mode 'fundamental-mode)
      (setq initial-scratch-message nil)

      ;; Avoid/streamline interactive questions.
      (defalias 'yes-or-no-p 'y-or-n-p)
      (setq confirm-kill-processes nil)
      (setq use-dialog-box nil)

      ;; Don't create backup/lockfiles.
      ;; This is the 21st century; we have git.
      (setq create-lockfiles nil)
      (setq make-backup-files nil)

      ;; `folder/filename' instead of `filename<2>'
      (setq uniquify-buffer-name-style 'forward)

      ;; Line style and indentation
      (setq-default indent-tabs-mode nil)
      (setq-default truncate-lines t)
      (setq-default fill-column 80)
      (setq require-final-newline t)

      ;; Scrolling
      (setq scroll-conservatively 101)
      (setq auto-hscroll-mode 'current-line)

      ;; Minibuffer
      (setq enable-recursive-minibuffers t)
      (setq max-mini-window-height 8)

      ;; Miscellaneous improvements
      (setq tab-always-indent 'complete)
      (setq Man-notify-method 'pushy)
      (setq ring-bell-function 'ignore)
      (setq line-spacing 0.1)))

  ;; Commands
  (use-package emacs
    :hook
    (after-init . repeat-mode)
    (after-init . r/enable-commands)
    :config
    (defun r/enable-commands ()
      (put 'narrow-to-region 'disabled nil)
      (put 'downcase-region 'disabled nil)
      (put 'upcase-region 'disabled nil)
      (put 'scroll-left 'disabled nil)
      (put 'scroll-right 'disabled nil)))
#+END_SRC

** Line Numbers
Some say that line numbers are something of an anti-pattern in Emacs, but
~display-line-numbers-mode~ doesn't seem to have an appreciable performance impact
and it's very helpful when discussing code with colleagues.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :hook
    (prog-mode . display-line-numbers-mode)
    (display-line-numbers-mode . hl-line-mode)
    :config
    (setq display-line-numbers-grow-only t)
    (setq-default display-line-numbers-width 3)
    (setq-default display-line-numbers-widen t))
  #+END_SRC

** History
Keeping track of where you've been and the things you've done is an incredible
time saver.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :hook
    (after-init . recentf-mode)
    (after-init . save-place-mode)
    (after-init . savehist-mode)
    (after-init . r/configure-history)
    :config
    (defun r/configure-history ()
      (with-eval-after-load 'recentf
        (setq recentf-max-saved-items 200)
        (add-to-list 'recentf-exclude '("\\/sudo:root@localhost.*"))
        (run-at-time nil (* 5 60) 'recentf-save-list))
      (setq savehist-additional-variables
            '(file-name-history
              search-ring
              command-history
              regexp-search-ring))))
#+END_SRC

** Modeline
The default modeline works well enough; I simply enable a few more bits of
information for it to show.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :hook
    (after-init . display-battery-mode)
    (after-init . display-time-mode)
    (after-init . column-number-mode)
    (after-init . r/modeline-info)
    :config
    (defun r/modeline-info ()
      (setq battery-mode-line-format "[%b%p%%] ")
      (setq datetime-timezone 'Europe/Vienna)
      (setq display-time-24hr-format 1)
      (setq display-time-format "[%H:%M] ")
      (setq display-time-default-load-average nil))

    (defun r/echo-modeline ()
      "Show the current mode line in the minibuffer. The minibuffer will
  grow to fit the whole thing, so any time information is out of
  view on the right fringe, call this function to see the rest."
      (interactive)
      (message "%s" (format-mode-line mode-line-format))))
#+END_SRC

** Dired
Dired is the greatest file manager ever created. The existence of ~wdired~ alone
makes it superior to any graphical file manager I've ever seen; add on
everything else dired is capable of, and there's just no contest.

#+BEGIN_SRC emacs-lisp
  (use-package dired
    :ensure nil
    :hook
    (dired-mode . dired-hide-details-mode)
    (dired-mode . auto-revert-mode)
    (after-init . (lambda () (load "dired-x")))
    :bind (:map dired-mode-map
                ("C-c C-e" . wdired-change-to-wdired-mode))
    :config
    (setq dired-listing-switches "-alh --group-directories-first")
    (setq dired-dwim-target t)
    (setq dired-clean-up-buffers-too nil))

  ;; Add some color to dired
  (use-package diredfl
    :hook (after-init . diredfl-global-mode))

  ;; This package lets you show subfolders in a tree view instead of
  ;; inserting them below. It's very slow on deeply nested directories,
  ;; so use it carefully.
  (use-package dired-subtree
    :vc (:fetcher github :repo Fuco1/dired-hacks)
    :commands r/dired-subtree-face-override
    :hook
    ;; HACK: for some reason, using `:bind' doesn't work consistently for this
    (dired-mode
     . (lambda () (bind-key [tab] #'dired-subtree-cycle 'dired-mode-map)))
    :config
    (defun r/dired-subtree-face-override ()
      (interactive)
      (with-eval-after-load 'org-faces
        (let ((facelist (r/face-filter "^dired-subtree-")))
          (dolist (face facelist)
            (set-face-attribute face nil :extend t :background 'unspecified))))))
#+END_SRC

** Calendar
All I really want in a calendar is to see the days of the month and the week
numbers. This thing does that beautifully, and it's right here.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    ;; Always highlight today if it's visible
    :hook (calendar-today-visible . calendar-mark-today)
    :config
    (setq calendar-week-start-day 1)
    ;; Show week numbers
    (setq calendar-intermonth-text
          '(propertize
            (format "%2d"
                    (car
                     (calendar-iso-from-absolute
                      (calendar-absolute-from-gregorian (list month day year)))))
            'font-lock-face 'font-lock-keyword-face)))
#+END_SRC

** Directories
Emacs normally fails to perform a file operation when trying to write or copy
files into directories which do not yet exist. This behavior is almost never
helpful; instead, if I'm working in the minibuffer and explicitly say to put a
file into a directory which does not yet exist, I mean that the directory should
be created and the file should be put there. This sort of DWIM behavior is
surprisingly lacking by default. This section fixes that oversight.

#+BEGIN_SRC emacs-lisp
  ;; Make missing directories instead of uselessly failing.
  (defun r/make-directory-if-not-exists (filename)
    "Create parent directory if not exists while operating on `FILENAME'."
    (unless (file-exists-p filename)
      (let ((dir (file-name-directory filename)))
        (unless (file-exists-p dir)
          (make-directory dir t)))))

  ;; TODO figure out how to do this with less duplication
  (defun r/advise-file-operations ()
    (defadvice find-file (before make-directory-maybe (filename &optional wildcards) activate)
      (r/make-directory-if-not-exists filename))
    (defadvice copy-file (before make-directory-maybe (file newname &optional ok-if-already-exists keep-time preserve-uid-gid preserve-permissions) activate)
      (r/make-directory-if-not-exists newname))
    (defadvice rename-file (before make-directory-maybe (file newname &optional ok-if-already-exists) activate)
      (r/make-directory-if-not-exists newname)))

  (r/run-idly #'r/advise-file-operations 1)
#+END_SRC
